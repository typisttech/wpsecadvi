/*
 * Copyright (c) 2022-2023 Typist Tech Limited
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package wordfence

import (
	"fmt"

	"github.com/typisttech/wpsecadvi/composer/version"
	"github.com/typisttech/wpsecadvi/wp"
)

// Vulnerability represents an item in the Wordfence data feed.
//
// See https://www.wordfence.com/intelligence-documentation/v2-accessing-and-consuming-the-vulnerability-data-feed/#data_format
type Vulnerability struct {
	// ID is a UUID string that serves as a unique identifier for the vulnerability.
	ID string `json:"id"`
	// Software is a list of affected software specified for each vulnerability.
	Software []Software `json:"software"`
	// CVE is the CVE ID (i.e. "CVE-1998-1000") when assigned, empty otherwise.
	CVE string `json:"cve"`
}

// Software represents the affected software and version information.
//
// See https://www.wordfence.com/intelligence-documentation/v2-accessing-and-consuming-the-vulnerability-data-feed/#software_format
type Software struct {
	// Type is one of "core", "plugin", or "theme".
	Type string `json:"type"`
	// Slug is an identifier for the software.
	Slug string `json:"slug"`
	// AffectedVersions is set of affected versions.
	AffectedVersions AffectedVersions `json:"affected_versions"`
}

// AffectedVersion represents
//
// See https://www.wordfence.com/intelligence-documentation/v2-accessing-and-consuming-the-vulnerability-data-feed/#affected_version_format
type AffectedVersion struct {
	FromVersion   string `json:"from_version"`
	FromInclusive bool   `json:"from_inclusive"`
	ToVersion     string `json:"to_version"`
	ToInclusive   bool   `json:"to_inclusive"`
}

type vulnerabilities []Vulnerability

func (vs vulnerabilities) entities() ([]*wp.Entity, error) {
	entities := make([]*wp.Entity, 0, len(vs))
	for _, v := range vs {
		es, err := v.entities()
		if err != nil {
			continue
		}

		entities = append(entities, es...)
	}

	if len(entities) == 0 {
		return nil, fmt.Errorf("unable to parse any wp entity from the %d vulnerabilities", len(vs))
	}

	return entities, nil
}

func (v Vulnerability) entities() ([]*wp.Entity, error) {
	es := make([]*wp.Entity, 0, len(v.Software))
	for _, s := range v.Software {
		e, err := s.entity()
		if err != nil {
			continue
		}

		es = append(es, e)
	}

	if len(es) == 0 {
		return nil, fmt.Errorf("unable to parse any wp entity from the %d software of vulnerability %s %s", len(v.Software), v.ID, v.CVE)
	}

	return es, nil
}

func (s Software) entity() (*wp.Entity, error) {
	var e *wp.Entity
	var err error

	switch s.Type {
	case "core":
		e = wp.NewCoreEntity()
	case "plugin":
		e, err = wp.NewPluginEntity(s.Slug)
		if err != nil {
			return nil, fmt.Errorf("unable to parse plugin entity: %w", err)
		}
	case "theme":
		e, err = wp.NewThemeEntity(s.Slug)
		if err != nil {
			return nil, fmt.Errorf("unable to parse theme entity: %w", err)
		}
	default:
		return nil, fmt.Errorf("unexpected software type: %s", s.Type)
	}

	c, err := s.AffectedVersions.constraint()
	if err != nil {
		return nil, fmt.Errorf("unable to parse entity constraint for %s (%s): %w", s.Type, e.Slug(), err)
	}

	e.Or(c)

	return e, nil
}

type AffectedVersions map[string]AffectedVersion

func (avs AffectedVersions) constraint() (version.Constraint, error) {
	c := version.Constraint{}

	for _, av := range avs {
		r, err := av.versionRange()
		if err != nil {
			continue
		}

		c = append(c, r)
	}

	if len(c) == 0 {
		return nil, fmt.Errorf("unable to parse any version constraint from the %d affected versions", len(avs))
	}

	return c, nil
}

func (av AffectedVersion) versionRange() (*version.Range, error) {
	var from *version.Version
	var err error
	if av.FromVersion != "*" {
		from, err = version.New(av.FromVersion)
		if err != nil {
			return nil, err
		}
	}

	var to *version.Version
	if av.ToVersion != "*" {
		to, err = version.New(av.ToVersion)
		if err != nil {
			return nil, err
		}
	}

	return version.NewRange(
		version.WithFloor(from, av.FromInclusive),
		version.WithCeiling(to, av.ToInclusive),
	)
}