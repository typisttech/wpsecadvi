/*
 * Copyright (c) 2022-2023 Typist Tech Limited
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package wordfence

import (
	"github.com/typisttech/wpsecadvi/composer"
	"github.com/typisttech/wpsecadvi/semver"
	"golang.org/x/exp/slices"
)

type vulnerabilities map[string]Vulnerability

func (vs vulnerabilities) softwareRanges(ignores []string) map[composer.PackageType]map[softwareSlug][]*semver.Range {
	// TODO: Refactor!
	ranges := make(map[composer.PackageType]map[softwareSlug][]*semver.Range)
	for _, vuln := range vs {
		ii := slices.IndexFunc(ignores, func(ignore string) bool {
			return vuln.ID == ignore || vuln.CVE == ignore
		})
		if ii >= 0 {
			continue
		}

		for _, s := range vuln.Software {
			t := s.packageType()
			if t == "" {
				continue
			}

			if s.Slug == "" {
				continue
			}

			for _, av := range s.AffectedVersions {
				r, err := av.semverRange()
				if err != nil {
					continue
				}

				if ranges[t] == nil {
					ranges[t] = make(map[softwareSlug][]*semver.Range)
				}

				ranges[t][s.Slug] = append(ranges[t][s.Slug], r)
			}
		}
	}

	return ranges
}

type Vulnerability struct {
	ID       string     `json:"id"`
	Software []Software `json:"software"`
	CVE      string     `json:"cve"`
}

type softwareSlug string

type Software struct {
	Type             string                     `json:"type"`
	Slug             softwareSlug               `json:"slug"`
	AffectedVersions map[string]AffectedVersion `json:"affected_versions"`
}

func (s Software) packageType() composer.PackageType {
	switch s.Type {
	case "core":
		return composer.WPCore
	case "plugin":
		return composer.WPPlugin
	case "theme":
		return composer.WPTheme
	}

	// TODO: Handle unexpected types.
	return ""
}

type AffectedVersion struct {
	FromVersion   string `json:"from_version"`
	FromInclusive bool   `json:"from_inclusive"`
	ToVersion     string `json:"to_version"`
	ToInclusive   bool   `json:"to_inclusive"`
}

func (av AffectedVersion) semverRange() (*semver.Range, error) {
	if av.FromVersion == "*" && av.ToVersion == "*" {
		return semver.NewWildcardRange()
	}

	if av.FromVersion == "*" {
		return semver.NewUpperBoundedRange(av.ToVersion, av.ToInclusive)
	}

	if av.ToVersion == "*" {
		return semver.NewLowerBoundedRange(av.FromVersion, av.FromInclusive)
	}

	return semver.NewRange(av.FromVersion, av.FromInclusive, av.ToVersion, av.ToInclusive)
}
