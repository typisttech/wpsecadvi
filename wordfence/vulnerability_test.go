/*
 * Copyright (c) 2022-2023 Typist Tech Limited
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package wordfence

import (
	"github.com/stretchr/testify/assert"
	"github.com/typisttech/wpsecadvi/composer"
	"testing"
)

func Test_vulnerabilities_softwareRanges(t *testing.T) {
	type args struct {
		ignores []string
	}
	tests := []struct {
		name     string
		vs       vulnerabilities
		args     args
		want     map[composer.PackageType]map[softwareSlug][]string
		dontWant map[composer.PackageType]map[softwareSlug][]string
	}{
		{
			name: "production_ignore_id",
			vs:   productionVulnerabilities,
			args: args{ignores: []string{"823e4567-e89b-12d3-a456-426655440000"}},
			want: productionSoftwareRanges,
			dontWant: map[composer.PackageType]map[softwareSlug][]string{
				composer.WPCore: {
					"wordpress": []string{"<=6.1.1"},
				},
			},
		},
		{
			name: "production_ignore_cve",
			vs:   productionVulnerabilities,
			args: args{ignores: []string{"CVE-2022-8888"}},
			want: productionSoftwareRanges,
			dontWant: map[composer.PackageType]map[softwareSlug][]string{
				composer.WPCore: {
					"wordpress": []string{"<=6.1.1"},
				},
			},
		},
	}
	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.vs.softwareRanges(tc.args.ignores)

			// TODO: Refactor!
			for pt, sRanges := range tc.want {
				assert.Contains(t, got, pt)

				for slug, rs := range sRanges {
					assert.Contains(t, got[pt], slug)

					gotRs := make([]string, 0, len(rs))
					for _, r := range got[pt][slug] {
						gotRs = append(gotRs, r.String())
					}

					assert.Subset(t, gotRs, rs)
				}
			}

			for pt, sRanges := range tc.dontWant {
				for slug, rs := range sRanges {
					gotRs := make([]string, 0, len(rs))
					for _, r := range got[pt][slug] {
						gotRs = append(gotRs, r.String())
					}

					assert.NotSubset(t, gotRs, rs)
				}
			}
		})
	}
}

func TestSoftware_packageType(t *testing.T) {
	type fields struct {
		Type string
	}
	tests := []struct {
		name   string
		fields fields
		want   composer.PackageType
	}{
		{
			name:   "core",
			fields: fields{Type: "core"},
			want:   composer.WPCore,
		},
		{
			name:   "core",
			fields: fields{Type: "plugin"},
			want:   composer.WPPlugin,
		},
		{
			name:   "core",
			fields: fields{Type: "theme"},
			want:   composer.WPTheme,
		},
		{
			name:   "unexpected",
			fields: fields{Type: "unexpected"},
			want:   "",
		},
	}
	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			s := Software{
				Type: tc.fields.Type,
			}

			assert.Equalf(t, tc.want, s.packageType(), "packageType()")
		})
	}
}

func TestAffectedVersion_semverRange(t *testing.T) {
	type fields struct {
		FromVersion   string
		FromInclusive bool
		ToVersion     string
		ToInclusive   bool
	}
	tests := []struct {
		name    string
		fields  fields
		want    string
		wantErr bool
	}{
		{
			name: "both_bounded",
			fields: fields{
				FromVersion:   "1",
				FromInclusive: false,
				ToVersion:     "1.2.3",
				ToInclusive:   false,
			},
			want:    ">1.0.0,<1.2.3",
			wantErr: false,
		},
		{
			name: "both_bounded_left_inclusive",
			fields: fields{
				FromVersion:   "1",
				FromInclusive: true,
				ToVersion:     "1.2.3",
				ToInclusive:   false,
			},
			want:    ">=1.0.0,<1.2.3",
			wantErr: false,
		},
		{
			name: "both_bounded_right_inclusive",
			fields: fields{
				FromVersion:   "1",
				FromInclusive: false,
				ToVersion:     "1.2.3",
				ToInclusive:   true,
			},
			want:    ">1.0.0,<=1.2.3",
			wantErr: false,
		},
		{
			name: "both_bounded_both_inclusive",
			fields: fields{
				FromVersion:   "1",
				FromInclusive: true,
				ToVersion:     "1.2.3",
				ToInclusive:   true,
			},
			want:    ">=1.0.0,<=1.2.3",
			wantErr: false,
		},
		{
			name: "lower_bounded",
			fields: fields{
				FromVersion:   "1",
				FromInclusive: false,
				ToVersion:     "*",
				ToInclusive:   true,
			},
			want:    ">1.0.0",
			wantErr: false,
		},
		{
			name: "lower_bounded_inclusive",
			fields: fields{
				FromVersion:   "1",
				FromInclusive: true,
				ToVersion:     "*",
				ToInclusive:   true,
			},
			want:    ">=1.0.0",
			wantErr: false,
		},
		{
			name: "upper_bounded",
			fields: fields{
				FromVersion:   "*",
				FromInclusive: true,
				ToVersion:     "3.2.1",
				ToInclusive:   false,
			},
			want:    "<3.2.1",
			wantErr: false,
		},
		{
			name: "upper_bounded_inclusive",
			fields: fields{
				FromVersion:   "*",
				FromInclusive: true,
				ToVersion:     "3.2.1",
				ToInclusive:   true,
			},
			want:    "<=3.2.1",
			wantErr: false,
		},
		{
			name: "wildcard",
			fields: fields{
				FromVersion:   "*",
				FromInclusive: true,
				ToVersion:     "*",
				ToInclusive:   true,
			},
			want:    "*",
			wantErr: false,
		},
		{
			name: "from_invalid_semantic_version",
			fields: fields{
				FromVersion:   "1.2.3.4",
				FromInclusive: true,
				ToVersion:     "9.9.9",
				ToInclusive:   true,
			},
			want:    "",
			wantErr: true,
		},
		{
			name: "to_invalid_semantic_version",
			fields: fields{
				FromVersion:   "1.1.1",
				FromInclusive: true,
				ToVersion:     "2.3.4.5",
				ToInclusive:   true,
			},
			want:    "",
			wantErr: true,
		},
		{
			name: "both_invalid_semantic_version",
			fields: fields{
				FromVersion:   "1.2.3.4",
				FromInclusive: true,
				ToVersion:     "2.3.4.5",
				ToInclusive:   true,
			},
			want:    "",
			wantErr: true,
		},
		{
			name: "from_informational",
			fields: fields{
				FromVersion:   "informational",
				FromInclusive: true,
				ToVersion:     "9.9.9",
				ToInclusive:   true,
			},
			want:    "",
			wantErr: true,
		},
		{
			name: "to_informational",
			fields: fields{
				FromVersion:   "1.1.1",
				FromInclusive: true,
				ToVersion:     "informational",
				ToInclusive:   true,
			},
			want:    "",
			wantErr: true,
		},
		{
			name: "both_informational",
			fields: fields{
				FromVersion:   "informational",
				FromInclusive: true,
				ToVersion:     "informational",
				ToInclusive:   true,
			},
			want:    "",
			wantErr: true,
		},
	}
	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			av := AffectedVersion{
				FromVersion:   tc.fields.FromVersion,
				FromInclusive: tc.fields.FromInclusive,
				ToVersion:     tc.fields.ToVersion,
				ToInclusive:   tc.fields.ToInclusive,
			}
			got, err := av.semverRange()

			if tc.wantErr {
				if err == nil {
					t.Errorf("semverRange() want error, got %v", err)
				}
				return
			}

			if err != nil {
				t.Errorf("semverRange() unexpected error, got %v", err)
				return
			}

			assert.Equalf(t, tc.want, got.String(), "semverRange().String")
		})
	}
}
